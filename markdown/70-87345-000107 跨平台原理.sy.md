---
show: step
version: 1.0
enable_checker: true
---

# 跨平台原理

## 回忆上次内容

- 我们这次分析了`class文件`的原理
- `class文件`是从`java源文件`编译生成的
- `class文件`是`java虚拟机`可以直接执行的`二进制指令`
- 我们可以对于`class文件`反汇编得到`class对应的汇编语言源文件`
- 可以找到`class文件`和`汇编语言源文件`之间的对应关系
- 对应关系就是`java虚拟机的指令集`字节码和指令之间的关系
- 为什么要有个`java虚拟机`，我直接在真实`cpu`上跑他不香么？🤔


![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615096839724)

### java虚拟机

- 到底什么是java虚拟机呢？
- 我们对他发出灵魂:ೖ(⑅σ̑ᴗσ̑)ೖ::三问

```
whatis java
whereis java
which java
```

- 这个java是一个二进制可执行文件
- 他在/usr/blib/jvm/java-8-openjdk-amd64/bin/java

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615096983621)

- 说白了虚拟机也是一个程序
- 虚拟机程序一开始在真实的硬盘上
- 然后加载到真实的内存里
- 然后可以虚拟出一个计算机
- 这个虚拟出来的计算机有虚拟的cpu和内存
- 可以把class放在虚拟机的虚拟cpu上跑
- 因为class本质上就是虚拟cpu的指令
- 但是这虚拟机也是运行在真实cpu的真实指令之上的

### 继续观察

```
which java
ls -lah  /usr/lib/jvm/java-8-openjdk-amd64/bin/java 
```

- 这是一个链接文件
- 指向上层的../jre/bin/jva

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615097671508)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615097686337)

### 仔细观察

```
ls -lah  /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java
```

- 这个java虚拟机文件大概6.4K
- java虚拟机就在硬盘里存着
	- 位置就在/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java
		- usr是用户user
		- jvm就是java virtural machine
		- java-8-openjdk-amd64是对应版本和架构
		- jre是Java Runtime Environment
- 在运行命令的时候
	- 把这个文件从硬盘装载到内存
	- 然后用cpu开始逐行执行指令


![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615097899350)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615097999859)

### 拷贝到～

- 这个二进制文件可以拷贝到～
	- ～是当前用户主文件夹
- 拷贝过来之后无法独立运行
	- 因为缺少libjli.so

```
cp /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java ~
```

### 研究jvm

```
vi java
```

- `%!xxd`可以看到这个文件二进制形态
	- `%`对应所有的行
		- 此文件总共405行
	- `!`执行外部命令
	- xxd显示当前文件二进制形态
- `%!xxd -r` 可以还原回到原状态

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615098427731)


- 一行是（16）<sub>10进制</sub>个字节
- <kbd>G</kbd>到最后一行
- 有大概405行
- 这些其实都是对应着计算机的指令
- 可是这个指令我们看不懂怎么办？

### 反汇编
```
objdump -d ~/java > java.asm
```

- 通过这个指令
- 将jvm对应的这个java二进制文件
- 反汇编成为了一个汇编语言文件

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615122131355)


### 查看java汇编指令

```shell
#分窗口分别打开打开java 和 java.asm
vi -o java java.asm
```

- 680就是这个程序段开始的地方
- 我们从上面也可以找到对应的位置
- `/4883 ec08 488b`可以搜索到合适的位置
- 这样就找到了具体的位置
- 在680这个地址存储的指令是4883 ec08
- 指令操作码对应的操作是sub $0x08,%rsp
- 为什么会有这样的对应关系？
- 源于这个系统的指令集

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615122696876)

### 查看指令集

- `0000 0680`对应着初始的cpu开始执行的地方
- `4883 ec08`找到上下的对应关系 
- 也就是第一条执行的汇编指令
- 汇编指令是计算机cpu指令的助记符
- 指令的集合就是计算机的架构
- 架构也叫指令集
- 不同架构的cpu就会有不同的指令集
	- 我们目前的这个是`x86-64`
	- 除此之外`arm`、`MIPS`、`RISC-V`也是常用的指令集
	- 不同的架构想运行相同的程序就需要移植
	- 如果不移植的话
		- 就像让一个意大利泥瓦匠看一份中文写成的烹饪书来砌墙
		- 鸡同鸭讲
		- 驴唇不对马嘴
- 这里会有不同的`section`模块
	- 模块里面是具体的指令
	- 比如`48 83 ec 08` 对应`sub $0x8,%rsp`
		- 这是一条减法指令 
		- 具体语法需要查询指令集(x86-64)对应的汇编文档手册

### 查看指令集

- 可以在`shell`用`uname -a`进行查看本机所用的指令集
- 当前指令集是x86_64

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210303-1614752188645)

- sub位于计算指令第5行

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210303-1614752112519)

### java执行过程
- 我们执行的过程大致是这样
- 1.把可执行文件从硬盘放入内存
- 2.使用cpu的指令集根据指令一条条的执行
- 3.在内存中生成java的虚拟机环境
- 4.把参数`hello.class`导入java虚拟机环境
	- `hello.class`其实是一系列虚拟机的虚拟指令
- 5.jvm解释执行虚拟机指令
- 6.然后完成

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615124404759)

- 为什么要有这么一个虚拟机呢？

### 虚拟机的意义

- 虚拟机jvm的意义在于跨平台
- 不同的系统
	- mac
	- windows
	- linux
- 这些不同的系统可能基于不同的架构
	- x86
	- x86-64
	- arm
	- mips
	- risc-v
- 不同架构上的不同的系统上面都有虚拟机jvm
- 只要你这个系统上有虚拟机jvm
- 就能运行class文件
- 同一个class文件在不同平台的虚拟机上运行结果一样
- 这样不就跨平台了么
- 只要有了class文件，在任何平台的jvm都能解释执行
- 实现一次编译，到处执行


![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615124380357)

### 虚拟机的定位

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210313-1615616373403)

- 上图是计算机系统的技术栈
- 虚拟机把硬件层面全都软件化
- 使用目前物理的cpu、内存、输入输出设备
- 在已有cpu的指令集之上架构了一套虚拟的jvm的cpu指令集
- 读取虚拟指令集的class可执行文件
- 在物理指令集上进行执行
- 这样，对应不同物理指令集，只要有虚拟机环境
	- 虚拟机环境指的就是把虚拟指令转化为物理指令的环境
- 虚拟机执行结果都相同

### 新的趋势

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210311-1615470473682)

- `龙芯`自有的指令集`loongson-3`可以有linux内核
- 而且`有Debian发行版`
	- 这上面就可以运行`java`
	- 还可以在`java`上运行`class`
- 中国自有产权的`cpu`
	- 以后可能也会有新的`内核`
	- 但应该也是兼容`linux kernel`的
	- 跨平台的特性
- 巨大的开发者队伍
	- 庞大的社区
	- 决定了`java`是一个持续的语言
- 总之，java应该说应用场景还是很广泛的

### 异想天开

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210313-1615616047515)

- 我能否制作一个真实的计算机的cpu
- 自己定制相应的指令集fpga之类的
- 然后指令集就采取jvm的指令集
- 这样，我就有了一个真实存在的物理上的jvm
- javac就变成了这个机器上真实的编译器
- 相关二进制文件不用java直接用cpu就能执行了
- System.out也就是真实的输出驱动了
- 这个幻想实在有点异想天开

## 总结

- 我们这次分析了jvm的原理
	- `class文件`是在`jvm`里面运行的
	- 也就是在`java虚拟机`可以直接执行的`二进制指令`
	- 我们对于`jvm`反汇编得到`jvm的汇编语言源文件`
	- 可以找到`java`和`java对应的汇编语言源文件`之间的对应关系
	- 对应关系就是`当前所用的指令集`
- 那不同架构 (不同指令集)是如何保持一致的呢？
	- 在不同架构和不同系统上面运行着和架构系统对应的`jvm`
	- `jvm`屏蔽了架构和系统的区别
	- 同一个`class`文件在不同系统架构下的`jvm`里，执行的结果是相同的
	- 也就实现了一次编译，到处运行
	- 只要有了`class`文件
	- 哪里运行都一样
- 那这个class文件怎么得到的来着？🤔
- 我们下次再说！👋